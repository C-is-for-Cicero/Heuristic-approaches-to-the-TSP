#include <iostream>
#include <fstream>
#include "utils.h"
#include "argparser.h"
#include "solver.h"
#include "randomTSP.h"
#include "solver.h"
#include "greedy.h"
#include <algorithm>
#include "pso.h"
#include "tabu.h"
using std::cout;
using std::endl;
using std::fixed;

// linux: g++ main.cpp && ./a.out --json=pathtosome.json
// windows 10 powershell:  g++ main.cpp && ./a.exe --json=pathtosome.json

int main(int argc, char *argv[]) {
  ArgParser p(argc, argv);
  /*
   * Without arguments, remove ArgParser and use:
   *
   * #include <fstream>
   * ...
   * std::ifstream i("pathtosome.json");
   * json data;
   * i >> data;
   * Graph G(data);
   */

  /*
  Graph * G = nullptr;
  if (p.get_seed() == 0) {
    G = new Graph(p.get_data());
  } else {
    G = new Graph(p.get_seed(),
      p.get_vertices_to_generate(),
      p.get_arcs_to_generate(), 1e2, 5e5);
  }
  if (p.get_save_filename() != "") {
    G->save_graph_as_json(p.get_save_filename());
  }
  //Solution s(G.get_vertices(), &G);
  //G.print_vertices(s.get_solution());
  //cout << fixed << s.get_objective() << endl;
  //cout << s.is_feasible() << endl;
*/

int choice_heur;


cout<<"*****************************************************************************"<<endl;
cout<<"**************************INGB321 ASSIGNMENT 6*******************************"<<endl;
cout<<"*******DB MYBURGH************************************24930237****************"<<endl;
cout<<"*****************************************************************************"<<endl;

cout<<"Please enter 1 for TSP10.json and 2 for TSP20.23.json"<<endl;
std::cin >> choice_heur;

if(choice_heur==1){
     std::ifstream i("TSP10.json");
      json data;
 i >> data;
 Graph* G = new Graph(data);
 RandomTSP* solver1 = new RandomTSP(G);

 cout<<endl<<"PSO"<<endl;
ParticleSwarm *solver2=new ParticleSwarm(G,solver1);

    solver2->solve_pso(10);

delete solver1;
    delete solver2;

    //Tabu Search

    //generate an initial feasible solution
    RandomTSP* solver3 = new RandomTSP(G);
    cout<<"Tabu"<<endl;

     TabuSearch *solver4=new TabuSearch(G,solver3);

    solver4->solve_Tabu(10);


/*
solve_tabu()

the solutions in the neighbourhood must be feasible
to do this loop through all vertices and swap them one by one
meaning swap vertex 1 with vertex 2,3,4,5,6,7,8
then vertex 2 with vertex 1,3,4,5,6,7,8
if the solution generated by each swap is feasible then it should be added to a vector of solutions
how to check for feasibility?-> try the inbuilt

while(neighborhoodvec.empty()!=1){

generate
setdifference(t and neighbourhoodvec)

for each x solution in set difference
    append x to T
        if obj x< xbest
            xbest=x
            remove element in T

tabu list temporarily holds a solution or solutions



}

*/




    delete solver3;
        delete solver4;
    //end tabu

  /*
   * How to get adjacent and incident vertices:
   *
   * get_adjacent_vertices for a vertex by id or pointer, example with an id:
   *
   *  G.print_vertices(G.get_adjacent_vertices(2220));
   *   or

   *  G.print_vertices(G.get_adjacent_vertices(some_vertex->id));
   *  same applies to get_incident_vertices(...)
   *
   * example with containers:
   *  for (auto v : G.get_vertices()) {
   *    G.print_vertices(G.get_adjacent_vertices(v));
   *    G.print_vertices(G.get_incident_vertices(v));
   *  }
   */

  Solver * solver = nullptr;
  /* If you are not using the argument parser,
   * do not use p.use_greedy, p.use_tabu, p.max_iterations, etc.
   * see greedy.h for an example of a solver implementation
   */

  //if(p.use_greedy() && !solver) {
    solver = new Greedy(G);
  //}

  //if (p.use_tabu() && (solver == nullptr))
  //  solver = new TabuSearch(G, p.max_iterations(), ...);

  //if (p.use_pso() && (solver == nullptr))
  //  solver = new PSO(G, p.max_iterations(), ...);


  // check if a solver was selected
  if (!solver || !G) {
    assert(solver);
    exit(127);
  }
  solver->solve();

//print solutions obtained
cout<<endl<<"GREEDY"<<endl;
 for (auto sol : solver->get_solutions()) {
G->print_vertices(sol->get_solution());
cout << "objective value: " << fixed << sol->get_objective() << endl;
}

  delete solver;



  return 0;
}

if(choice_heur==2){
     std::ifstream i("TSP20.23.json");
      json data;
 i >> data;
 Graph* G = new Graph(data);
 RandomTSP* solver1 = new RandomTSP(G);

 cout<<endl<<"PSO"<<endl;
ParticleSwarm *solver2=new ParticleSwarm(G,solver1);

    solver2->solve_pso(50);

delete solver1;
    delete solver2;

    //Tabu Search

    //generate an initial feasible solution
    RandomTSP* solver3 = new RandomTSP(G);
    cout<<"Tabu"<<endl;

     TabuSearch *solver4=new TabuSearch(G,solver3);

    solver4->solve_Tabu(50);


/*
solve_tabu()

the solutions in the neighbourhood must be feasible
to do this loop through all vertices and swap them one by one
meaning swap vertex 1 with vertex 2,3,4,5,6,7,8
then vertex 2 with vertex 1,3,4,5,6,7,8
if the solution generated by each swap is feasible then it should be added to a vector of solutions
how to check for feasibility?-> try the inbuilt

while(neighborhoodvec.empty()!=1){

generate
setdifference(t and neighbourhoodvec)

for each x solution in set difference
    append x to T
        if obj x< xbest
            xbest=x
            remove element in T

tabu list temporarily holds a solution or solutions



}

*/




    delete solver3;
        delete solver4;
    //end tabu

  /*
   * How to get adjacent and incident vertices:
   *
   * get_adjacent_vertices for a vertex by id or pointer, example with an id:
   *
   *  G.print_vertices(G.get_adjacent_vertices(2220));
   *   or

   *  G.print_vertices(G.get_adjacent_vertices(some_vertex->id));
   *  same applies to get_incident_vertices(...)
   *
   * example with containers:
   *  for (auto v : G.get_vertices()) {
   *    G.print_vertices(G.get_adjacent_vertices(v));
   *    G.print_vertices(G.get_incident_vertices(v));
   *  }
   */

  Solver * solver = nullptr;
  /* If you are not using the argument parser,
   * do not use p.use_greedy, p.use_tabu, p.max_iterations, etc.
   * see greedy.h for an example of a solver implementation
   */

  //if(p.use_greedy() && !solver) {
    solver = new Greedy(G);
  //}

  //if (p.use_tabu() && (solver == nullptr))
  //  solver = new TabuSearch(G, p.max_iterations(), ...);

  //if (p.use_pso() && (solver == nullptr))
  //  solver = new PSO(G, p.max_iterations(), ...);


  // check if a solver was selected
  if (!solver || !G) {
    assert(solver);
    exit(127);
  }
  solver->solve();

//print solutions obtained
cout<<endl<<"GREEDY"<<endl;
 for (auto sol : solver->get_solutions()) {
G->print_vertices(sol->get_solution());
cout << "objective value: " << fixed << sol->get_objective() << endl;
}

  delete solver;



  return 0;

}

}

